{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"qbin - a compact binary format for OpenQASM 3","text":"<p><code>qbin</code> is a minimal, lossless binary encoding for a useful subset of OpenQASM.</p> <p>It focuses on code you actually run on hardware (single-/two-qubit gates, rotations, measurement, and simple conditionals), so state-init circuits and large templated programs shrink dramatically versus plain text QASM.</p>"},{"location":"#why-qbin","title":"Why qbin?","text":"<ul> <li>Size matters: init/state-prep circuits and large parametrized templates shrink a lot.</li> <li>Streaming-friendly: one-pass, sectioned layout.</li> <li>Round-trip exactness: supported subset decompiles to identical QASM.</li> </ul> <p>Repository</p> <p>Project web</p> <p>See Quick start and CLI usage to begin.</p> <p>Check architecture for more info about format.</p>"},{"location":"architecture/","title":"QBIN Architecture","text":"<p>Status: DRAFT Audience: developers of the spec, compiler, decompiler, libraries, and tools</p> <p>This document explains the architecture of the QBIN project and how the components fit together. It complements the normative format definition in <code>spec/qbin-spec.md</code> and the developer cheat sheet in <code>spec/qbin-quickref.md</code>.</p>"},{"location":"architecture/#1-goals-and-non-goals","title":"1) Goals and Non-Goals","text":"<p>Goals: - Compact, stream-decodable representation of OpenQASM programs. - Stable containers with clear versioning and forward compatibility. - Clean separation between specification, libraries, and tools. - Easy round-trip: QASM -&gt; QBIN -&gt; QASM with predictable fidelity. - Vendor extension points that do not break core compatibility.</p> <p>Non-goals (v1): - Full general-purpose bytecode semantics (loops, arbitrary classical compute). - VM execution environment. QBIN is a container + instruction stream, not a VM.</p>"},{"location":"architecture/#2-project-layout-high-level","title":"2) Project Layout (high-level)","text":"<pre><code>qbin/\n  spec/                -&gt; Format specification and quick reference\n  lib/                 -&gt; Reference libraries (C++, Python, Rust)\n  compiler/            -&gt; QASM -&gt; QBIN CLI and front-ends\n  decompiler/          -&gt; QBIN -&gt; QASM CLI\n  tools/               -&gt; validators, inspectors, scripts\n  examples/            -&gt; QASM and QBIN examples and round-trip\n  tests/               -&gt; unit, conformance, fuzz\n  docs/                -&gt; architecture, roadmap, design decisions\n</code></pre>"},{"location":"architecture/#3-format-layers-data-model","title":"3) Format Layers (data model)","text":"<p>QBIN is a layered container:</p> <pre><code>+----------------------+\n|  Header (fixed)      |\n+----------------------+\n|  Section Table       |\n+----------------------+\n|  Sections...         |\n|  - INST (required)   |\n|  - STRS, META, ...   |\n|  - EXTS (optional)   |\n+----------------------+\n</code></pre> <ul> <li>Header: magic, version, counts, offsets, CRC.</li> <li>Section Table: descriptors (id, offset, size, flags).</li> <li>Sections: independent typed payloads, 8-byte aligned.</li> <li>INST: instruction stream (opcodes + operand mask + operands).</li> <li>Optional sections add metadata, strings, gates, debug, signatures.</li> </ul>"},{"location":"architecture/#4-component-overview","title":"4) Component Overview","text":""},{"location":"architecture/#41-libqbin-reference-library","title":"4.1 libqbin (reference library)","text":"<ul> <li>Parse/validate: header, table, section ranges, checksums.</li> <li>Section readers/writers: STRS, META, QUBS, BITS, PARS, GATE, INST, DEBG, SIGN.</li> <li>Error taxonomy aligned with spec (ERR_*).</li> <li>Streaming decode of INST (zero-copy where possible).</li> <li>ABI-stable C API (thin) over C++ classes for easier bindings.</li> <li>Python and Rust bindings reuse the C API surface.</li> </ul>"},{"location":"architecture/#42-compiler-qbin-compile","title":"4.2 Compiler (qbin-compile)","text":"<p>Pipeline:</p> <pre><code>QASM text --&gt; Front-end (lexer+parser) --&gt; IR (normalized ops)\n         --&gt; Lowering to QBIN opcodes --&gt; Section assembly\n         --&gt; Header+Table+INST (+STRS/META/GATE/DEBG as requested)\n</code></pre> <p>Key choices: - Normalize gate set to v1 core opcodes; custom gates go to GATE+CALLG. - Parameters become PARS entries; angles either literal or param_ref. - Qubit and bit indices normalized to zero-based ints. - Optional: emit STRS/META for better decompilation fidelity.</p>"},{"location":"architecture/#43-decompiler-qbin-decompile","title":"4.3 Decompiler (qbin-decompile)","text":"<p>Pipeline:</p> <pre><code>QBIN --&gt; Reader --&gt; Validate --&gt; Recreate textual QASM\n      --&gt; Reconstruct declarations, names (from STRS/QUBS/BITS)\n      --&gt; Emit QASM 2.x or 3.x dialects as requested\n</code></pre> <p>Notes: - If names are missing, synthesize like q[0], c[1]. - CALLG resolved against GATE; opaque gates emitted as calls.</p>"},{"location":"architecture/#44-tools","title":"4.4 Tools","text":"<ul> <li>qbin-validate: syntax + structural validation, checksums, alignment.</li> <li>qbin-inspect: header/table dump, section hexdumps, INST decode.</li> <li>Fuzz harness: libFuzzer/AFL entry points for <code>reader</code> functions.</li> <li>Corpus management scripts, conformance runner.</li> </ul>"},{"location":"architecture/#5-data-flow-and-apis","title":"5) Data Flow and APIs","text":""},{"location":"architecture/#51-read-path-pseudocode","title":"5.1 Read Path (pseudocode)","text":"<pre><code>read_all(fd):\n  hdr = read_header(fd)\n  check_crc(hdr)\n  table = read_section_table(fd, hdr.section_count, hdr.section_table_*)\n  for entry in table:\n    ensure_aligned(entry.offset)\n    ensure_inbounds(entry)\n  sections = { id: map_entry(fd, entry) }\n  inst = parse_INST(sections[\"INST\"])\n  return QBIN(hdr, table, sections, inst)\n</code></pre>"},{"location":"architecture/#52-write-path-pseudocode","title":"5.2 Write Path (pseudocode)","text":"<pre><code>encode(qbin):\n  layout = plan_layout(qbin.sections)           # compute sizes/offsets\n  hdr = build_header(layout)\n  hdr.crc = crc32c(hdr[0:0x14])                 # CRC over 0x00..0x13\n  buf = [hdr, build_table(layout)]\n  for sec in layout.sections_in_order:\n    payload = encode_section(sec)\n    if sec.flags.compressed:\n      payload = compress(payload, alg)\n    if sec.flags.checksummed:\n      payload += trailer_crc(payload)\n    buf.append(align8(payload))\n  return concat(buf)\n</code></pre>"},{"location":"architecture/#53-public-api-surfaces","title":"5.3 Public API Surfaces","text":"<p>C++:</p> <pre><code>class QbinReader {\n public:\n  static QbinFile read(std::span&lt;const uint8_t&gt; bytes);\n};\n\nclass QbinWriter {\n public:\n  static std::vector&lt;uint8_t&gt; write(const QbinFile&amp; f);\n};\n</code></pre> <p>C ABI (for bindings):</p> <pre><code>int qbin_read(const uint8_t* data, size_t len, qbin_file_t** out);\nint qbin_write(const qbin_file_t* in, uint8_t** out, size_t* out_len);\nvoid qbin_free(void* p);\n</code></pre> <p>Python:</p> <pre><code>import qbin\nf = qbin.read(b)\nb = qbin.write(f)\n</code></pre>"},{"location":"architecture/#6-instruction-encoding-summary","title":"6) Instruction Encoding (summary)","text":"<p>Instruction = <code>opcode (u8)</code> + <code>operand_mask (u8)</code> + operands. Operand mask bits:</p> <pre><code>0: a (varint)   1: b (varint)   2: c (varint)\n3: angle_0      4: angle_1      5: angle_2\n6: param_ref    7: aux_u32\n</code></pre> <p>Angle slot: <code>u8 tag (0=f32, 1=param_ref) + payload</code>.</p> <p>Rationale: - Constant-size opcode header; variable-size operands for compactness. - Varint for indices; f32 for angles; param_ref enables symbolic reuse.</p>"},{"location":"architecture/#7-names-metadata-and-fidelity","title":"7) Names, Metadata, and Fidelity","text":"<ul> <li>STRS: deduplication of names/keys; referenced via IDs.</li> <li>META: binary KV, avoids JSON parser; used for provenance and target info.</li> <li>QUBS/BITS: preserve register naming and sizes for round-trip readability.</li> <li>PARS: stable parameter IDs and kinds; literal vs ref recorded at use-sites.</li> <li>DEBG: optional file/line/column mapping for decompilers and IDEs.</li> </ul> <p>Round-trip policies are documented in <code>spec/qbin-spec.md</code> section 13.</p>"},{"location":"architecture/#8-security-and-robustness","title":"8) Security and Robustness","text":"<ul> <li>All inputs untrusted: validate ranges, counts, overlaps, alignment.</li> <li>Compression bombs: cap <code>raw_size</code> and compression ratios.</li> <li>Checksums and signatures: optional integrity and authenticity.</li> <li>EXTS and GATE bodies: never execute; only parse/validate unless explicitly enabled.</li> <li>Bounded recursion for IF/ENDIF nesting when decoding.</li> </ul>"},{"location":"architecture/#9-performance-considerations","title":"9) Performance Considerations","text":"<ul> <li>Streaming decode of INST to avoid large intermediate ASTs.</li> <li>Use contiguous buffers and span/slice views (no copies) in readers.</li> <li>Prefer varint for indices and sparse IDs; normalize index order.</li> <li>Optional zstd compression for large STRS/DEBG sections.</li> <li>Align sections to 8 bytes to help mmap and DMA-friendly IO.</li> </ul> <p>Target outcomes (indicative): - 5x\u201320x smaller than QASM for long gate streams. - O(1) per-instruction decode; linear scan with no tokenization.</p>"},{"location":"architecture/#10-testing-strategy","title":"10) Testing Strategy","text":"<ul> <li>Unit tests: per-section encode/decode.</li> <li>Round-trip tests: QASM -&gt; QBIN -&gt; QASM equivalence (semantic).</li> <li>Conformance suite: canonical <code>.qbin</code> fixtures with hashes.</li> <li>Fuzzing: structure-aware fuzzers for <code>reader</code> entry points.</li> <li>Cross-language parity: C++ vs Python decoders read same fixtures.</li> </ul> <p>CI: - Build on Linux/macOS/Windows. - Run ctest + pytest + fuzz smoke. - Artifacts: reference <code>.qbin</code> fixtures and coverage reports.</p>"},{"location":"architecture/#11-extension-mechanism","title":"11) Extension Mechanism","text":"<p>EXTS section registers: - New opcodes and operand schemas. - Expression DAGs used by PARS (symbolic math). - Vector operands (qubit lists), multi-control gates.</p> <p>Rules: - Unknown sections must be skippable. - Unknown opcodes: report <code>ERR_UNSUPPORTED_OPCODE</code> unless EXTS map provided. - Minor versions cannot break existing encodings.</p>"},{"location":"architecture/#12-integration-examples","title":"12) Integration Examples","text":"<ul> <li>CLI workflow:</li> </ul> <pre><code>qbin-compile program.qasm -o program.qbin --meta target=ibm_brisbane\nqbin-inspect program.qbin --inst\nqbin-decompile program.qbin -o program_roundtrip.qasm --qasm 3\n</code></pre> <ul> <li>IDE integration (e.g., VS Code extension):</li> <li>Use Python binding to decode <code>.qbin</code> for quick previews.</li> <li>Map DEBG to source lines for inline annotations.</li> <li>Send <code>.qbin</code> over IPC instead of large QASM text for speed.</li> </ul>"},{"location":"architecture/#13-roadmap-excerpt","title":"13) Roadmap (excerpt)","text":"<ul> <li>v1.0-draft freeze -&gt; conformance fixtures -&gt; reference reader/writer (C++)</li> <li>qbin-compile/decompile MVP -&gt; Python binding -&gt; Rust binding</li> <li>qbin-inspect GUI (optional) -&gt; integration with IDEs</li> <li>v1.1: EXTS registry, vector operands, richer conditionals</li> </ul> <p>Full roadmap in <code>docs/roadmap.md</code> (WIP).</p>"},{"location":"architecture/#14-glossary","title":"14) Glossary","text":"<ul> <li>INST: Instruction stream section.</li> <li>STRS: String table.</li> <li>META: Metadata section.</li> <li>QUBS/BITS: Qubit/bit tables.</li> <li>PARS: Parameter table.</li> <li>GATE: Custom gate table.</li> <li>DEBG: Debug mapping.</li> <li>SIGN: Detached signature.</li> <li>EXTS: Extension registry.</li> </ul>"},{"location":"cli/","title":"CLI usage","text":"<p>This project provides two command line tools:</p> <ul> <li>qbin-compile: convert OpenQASM source into QBIN format</li> <li>qbin-decompile: convert QBIN back into OpenQASM</li> </ul>"},{"location":"cli/#compile-openqasm-to-qbin","title":"Compile OpenQASM to QBIN","text":"<pre><code>build/compiler/qbin-compile path/to/input.qasm -o out.qbin\n</code></pre> <ul> <li><code>input.qasm</code>: OpenQASM source file</li> <li><code>-o out.qbin</code>: output file in QBIN format</li> </ul>"},{"location":"cli/#decompile-qbin-to-openqasm","title":"Decompile QBIN to OpenQASM","text":"<pre><code>build/decompiler/qbin-decompile out.qbin -o roundtrip.qasm\n</code></pre> <ul> <li><code>out.qbin</code>: QBIN file produced earlier</li> <li><code>-o roundtrip.qasm</code>: reconstructed OpenQASM source</li> </ul> <p>The decompiler preserves canonical formatting for the supported subset and always ends the file with a blank line. This guarantees exact round-trip comparisons in the test suite.</p>"},{"location":"cli/#notes","title":"Notes","text":"<ul> <li>Both tools are generated after building with CMake or running <code>scripts/bootstrap.sh</code>.</li> <li>Executables live in <code>build/compiler/</code> and <code>build/decompiler/</code>.</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Installation</p>"},{"location":"quickstart/","title":"Quick start (Linux/macOS)","text":"<p>Requirements: - CMake &gt;= 3.16 - C++17 compiler - Python 3</p>"},{"location":"quickstart/#one-command-build-test","title":"One command (build + test)","text":"<pre><code>./scripts/bootstrap.sh        # Release build\n./scripts/bootstrap.sh Debug  # Debug build\n</code></pre>"},{"location":"quickstart/#manual-cmake-alternative","title":"Manual CMake (alternative)","text":"<pre><code>cmake --preset dev\ncmake --build --preset dev\nctest --preset dev --output-on-failure\n</code></pre>"},{"location":"quickstart/#artifacts-after-build","title":"Artifacts after build","text":"<ul> <li>build/compiler/qbin-compile</li> <li>build/decompiler/qbin-decompile</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#git-password-authentication-not-supported","title":"Git password authentication not supported","text":"<p>Use SSH or a Personal Access Token.</p>"},{"location":"troubleshooting/#bootstrapsh-not-executable","title":"bootstrap.sh not executable","text":"<p>```bash bash scripts/bootstrap.sh chmod +x scripts/bootstrap.sh</p>"},{"location":"usage/","title":"Usage","text":"<p>Usage</p>"}]}